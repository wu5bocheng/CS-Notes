# Principles of Database Systems
<!-- GFM-TOC -->
* [Principles of Database Systems](#principles-of-database-systems)
    * [I. Transactions](#i-transactions)
        * [Concepts](#concepts)
        * [ACID](#acid)
        * [AUTOCOMMIT](#autocommit)
    * [II. Concurrency and Consistency Issues](#ii-concurrency-and-consistency-issues)
        * [Lost Updates](#lost-updates)
        * [Dirty Reads](#dirty-reads)
        * [Non-repeatable Reads](#non-repeatable-reads)
        * [Phantom Reads](#phantom-reads)
    * [III. Locking](#iii-locking)
        * [Granularity of Locks](#granularity-of-locks)
        * [Types of Locks](#types-of-locks)
        * [Locking Protocols](#locking-protocols)
        * [MySQL Implicit and Explicit Locking](#mysql-implicit-and-explicit-locking)
    * [IV. Isolation Levels](#iv-isolation-levels)
        * [Read Uncommitted](#read-uncommitted)
        * [Read Committed](#read-committed)
        * [Repeatable Read](#repeatable-read)
        * [Serializable](#serializable)
    * [V. Multi-Version Concurrency Control](#v-multi-version-concurrency-control)
        * [Basic Concepts](#basic-concepts)
        * [Version Numbers](#version-numbers)
        * [Undo Logs](#undo-logs)
        * [ReadView](#readview)
        * [Snapshot Reads vs Current Reads](#snapshot-reads-vs-current-reads)
    * [VI. Next-Key Locks](#vi-next-key-locks)
        * [Record Locks](#record-locks)
        * [Gap Locks](#gap-locks)
        * [Next-Key Locks](#next-key-locks)
    * [VII. Relational Database Design Theory](#vii-relational-database-design-theory)
        * [Functional Dependencies](#functional-dependencies)
        * [Anomalies](#anomalies)
        * [Normalization](#normalization)
    * [VIII. ER Diagrams](#viii-er-diagrams)
        * [Three Types of Entity Relationships](#three-types-of-entity-relationships)
        * [Representing Relationships Occurring Multiple Times](#representing-relationships-occurring-multiple-times)
        * [Multi-directional Relationships](#multi-directional-relationships)
        * [Representing Subclasses](#representing-subclasses)
    * [References](#references)
<!-- GFM-TOC -->

## 一、Transaction

### Concept

A transaction refers to a set of operations that satisfy the ACID characteristics. A transaction can commit a transaction by Commit, or roll back using Rollback.

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222237925.png"/> </div><br>

### ACID

#### 1. Atomicity (Atomicity)

A transaction is considered an indivisible minimum unit. All operations of a transaction are要么全部提交成功要么全部失败回滚.

Rollback can be implemented using rollback logs (Undo Log), which record the modified operations performed by the transaction. When rolling back, these modified operations can be performed in the reverse direction.

#### 2. Consistency (Consistency)

The database remains in a consistent state before and after the transaction is executed. In a consistent state, all transactions have the same read results for the same data.

#### 3. Isolation (Isolation)

The modifications made by a transaction are not visible to other transactions until they are finally committed.

#### 4. Durability (Durability)

Once a transaction is committed, the modifications it makes will be saved to the database forever. Even if the system crashes, the result of the transaction execution will not be lost.

System crashes can be recovered using redo logs (Redo Log) to achieve durability. Unlike rollback logs, which record logical modifications to data, redo logs record physical modifications to data pages.

----

Although the ACID characteristics of transactions are simple in concept, they are not easy to understand, mainly because these characteristics are not at the same level:

- Only when consistency is satisfied, the execution result of the transaction is correct.
- In the absence of concurrency, when transactions are executed serially, isolation can be guaranteed. At this time, as long as atomicity is satisfied, consistency is also guaranteed.- In the case of concurrency, multiple transactions are executed in parallel. In addition to satisfying atomicity, transactions also need to satisfy isolation to satisfy consistency.
- The persistence of transactions is to be able to cope with system crashes.

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207210437023.png"/> </div><br>

### AUTOCOMMIT

MySQL defaults to the auto-commit mode. That is, if you do not explicitly use the `START TRANSACTION` statement to start a transaction, each query operation will be treated as a transaction and automatically committed.

## 2. CONCURRENCY CONSISTENCY ISSUES

In a concurrent environment, it is difficult to ensure the isolation of transactions, resulting in many concurrency consistency issues.

### Lost Update

Lost update refers to an update operation in one transaction being replaced by an update operation in another transaction. This often occurs in real life. For example, there are two transactions, T<sub>1</sub> and T<sub>2</sub>, that both modify a data. T<sub>1</sub> modifies and commits first, and T<sub>2</sub> modifies later. T<sub>2</sub>'s modification overwrites T<sub>1</sub>'s modification.

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221744244.png"/> </div><br>

### Dirty Read

Dirty read refers to a situation where in different transactions, the current transaction can read the uncommitted data of another transaction. For example, T<sub>1</sub> modifies a data but does not commit, and T<sub>2</sub> reads this data subsequently. If T<sub>1</sub> cancels this modification, then the data read by T<sub>2</sub> is dirty data.

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221920368.png"/> </div><br>

### Non-repeatable Read

 Non-repeatable read refers to multiple reads of the same data set within one transaction. Before this transaction has ended, another transaction also accesses the same data set and makes modifications. Due to the modifications of the second transaction, the first transaction's two reads of the data may be inconsistent. For example, T<sub>2</sub> reads a data, and T<sub>1</sub> modifies this data. If T<sub>2</sub> reads this data again, the result of the read may be different from the first time.

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222102010.png"/> </div><br>

### Phantom Read

 Phantom read essentially belongs to the case of non-repeatable read. T<sub>1</sub> reads a certain range of data, and T<sub>2</sub> inserts new data within this range. T<sub>1</sub> reads this range of data again, and the result of the read is different from the first time.

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222134306.png"/> </div><br>

----

The main reason for the occurrence of concurrency inconsistency is the violation of the isolation of transactions. The solution is to ensure isolation through concurrent control. Concurrent control can be implemented through locking, but the locking operation requires the user to control it, which is相当 complex. The database management system provides the isolation level of transactions, allowing users to handle concurrency consistency issues in a more relaxed manner.

## 3. LOCKING

### Locking Granularity

MySQL provides two types of locking granularity: row-level locking and table-level locking.

It is best to only lock the part of the data that needs to be modified, rather than all resources. The less data locked, the less likely there is a lock contention, and the higher the system's concurrency.

However, adding locks consumes resources, and the various operations of the lock (including obtaining the lock, releasing the lock, and checking the lock status) increase system overhead. Therefore, the smaller the locking granularity, the greater the system overhead.

When choosing the locking granularity, a trade-off needs to be made between lock overhead and concurrency.- When a transaction adds an X lock to a data object A, it can read and update A. No other transaction can add any lock to A during the locking period.
- When a transaction adds an S lock to a data object A, it can read A, but cannot update it. Other transactions can add an S lock to A during the locking period, but cannot add an X lock.

The compatible relationship of locks is as follows:

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207213523777.png"/> </div><br>

#### 2. Intentional Locks

The use of intentional locks (Intention Locks) can make it easier to support multigranular locking.

In the presence of row-level and table-level locks, transaction T wants to add an X lock to table A, it is necessary to first detect whether there are other transactions that have locked table A or any row in table A, then it is necessary to detect each row of table A one by one, which is very time-consuming.

Intentional locks introduce IX/IS on top of the original X/S locks, where IX/IS are table locks to indicate that a transaction wants to add an X or S lock to a certain data row in the table. There are the following two stipulations:

- Before a transaction obtains an S lock on a certain data row object, it must first obtain an IS lock or a stronger lock on the table;
- Before a transaction obtains an X lock on a certain data row object, it must first obtain an IX lock on the table.

By introducing intentional locks, when transaction T wants to add an X lock to table A, it only needs to first detect whether there are other transactions that have added X/IX/S/IS locks to table A. If so, it means that there are other transactions using the lock of this table or some rows in the table, so transaction T fails to add the X lock.

The compatible relationship of various locks is as follows:

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207214442687.png"/> </div><br>

The following is explained:

- Any IS/IX lock is compatible because they only indicate an intention to add a lock to the table, rather than a real lock;
- The compatible relationship in this case is for table-level locks, and the IX lock at the table level and the X lock at the row level are compatible, and two transactions can add an X lock to two data rows. (Transaction T<sub>1</sub> wants to add an X lock to data row R<sub>1</sub>, and transaction T<sub>2</sub> wants to add an X lock to the same data row R<sub>2</sub> in the table. Both transactions need to add an IX lock to the table, but the IX lock is compatible, and the IX lock is also compatible with the row-level X lock, so both transactions can successfully lock and modify two data rows in the same table.)

### Locking Protocol

#### 1. Three-level Locking Protocol

**Level 1 Locking Protocol**  

When a transaction T wants to modify data A, it must add an X lock until T ends to release the lock.

This can solve the problem of lost modifications, because two transactions cannot modify the same data at the same time, so the transaction's modification will not be overwritten.

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207220440451.png"/> </div><br>

**Level 2 Locking Protocol**  

Based on level 1, it is required to add an S lock when reading data A, and release the S lock immediately after reading.

This can solve the problem of reading dirty data, because if a transaction modifies data A, according to level 1 locking protocol, an X lock will be added, then an S lock cannot be added, that is, data will not be read in.

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207220831843.png"/> </div><br>

**Level 3 Locking Protocol**  

Based on level 2, it is required to add an S lock when reading data A, and release the S lock until the transaction ends.

This can solve the problem of non-repeatable reads, because when reading A, other transactions cannot add an X lock to A, thereby avoiding the data changing during the reading period.

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221313819.png"/> </div><br>

#### 2. Two-phase Locking Protocol

Locking and unlocking are performed in two phases.

Serializable scheduling means that through concurrent control, the results of concurrent execution of transactions are the same as those of a certain serial execution of transactions. Serial execution of transactions do not interfere with each other and do not have concurrent consistency problems.Two-phase locking protocol is a sufficient condition to ensure a serializable schedule. For example, the following operations satisfy the two-phase locking protocol and are serializable schedules.

```html
lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
```

But it is not a necessary condition. For example, the following operations do not satisfy the two-phase locking protocol, but they are still serializable schedules.

```html
lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
```

### Implicit and Explicit Locks in MySQL

The InnoDB storage engine of MySQL adopts the two-phase locking protocol, and will automatically lock when necessary according to the isolation level, and all locks are released at the same time, which is called implicit locking.

InnoDB can also use specific statements for explicit locking:

```sql
SELECT...LOCK IN SHARE MODE;
SELECT...FOR UPDATE;
```

## Four, Isolation Levels

### Uncommitted Read (READ UNCOMMITTED)

Modifications in a transaction are visible to other transactions even if they have not been committed.

### Committed Read (READ COMMITTED)

A transaction can only read the modifications made by a committed transaction. In other words, the modifications made by a transaction are not visible to other transactions before they are committed.

### Repeatable Read (REPEATABLE READ)

Ensures that the same data is read the same number of times within the same transaction.

### Serializable (SERIALIZABLE)

Forces transactions to execute serially, so that multiple transactions do not interfere with each other and there will be no concurrency consistency issues.

This isolation level requires locking to be implemented, because the locking mechanism is used to ensure that only one transaction is执行 at a time, that is, to ensure that transactions are executed serially.

----

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207223400787.png"/> </div><br>

## Five, Multi-Version Concurrency Control

Multi-Version Concurrency Control (Multi-Version Concurrency Control, MVCC) is a specific implementation of the InnoDB storage engine of MySQL to achieve isolation levels, used to implement two isolation levels of committed read and repeatable read. And the uncommitted read isolation level always reads the latest data row, with very low requirements and does not require the use of MVCC. The serializable isolation level requires locking for all read rows, and MVCC alone cannot be implemented.

### Basic Idea

As mentioned in the section on locking, locking can solve the concurrent consistency issues that arise when multiple transactions are executed simultaneously. In actual scenarios, read operations are often more numerous than write operations, so read-write locks are introduced to avoid unnecessary locking operations, such as when reading and reading do not have a mutual exclusion relationship. In read-write locks, read and write operations are still mutually exclusive, while MVCC takes advantage of the idea of multiple versions. Write operations update the latest version snapshot, while read operations read the old version snapshot, without mutual exclusion, similar to CopyOnWrite.

In MVCC, a transaction's modified operation (DELETE, INSERT, UPDATE) creates a new version snapshot for the data row.

The root cause of dirty reads and non-repeatable reads is that a transaction reads uncommitted modifications made by other transactions. When a transaction performs a read operation, to solve the problem of dirty reads and non-repeatable reads, MVCC stipulates that only committed snapshots can be read. Of course, a transaction can read its own uncommitted snapshots, which does not count as a dirty read.

### Version Number

- System version number SYS_ID: is an increasing number, and every time a new transaction starts, the system version number will automatically increase.
- Transaction version number TRX_ID: the system version number at the beginning of the transaction.

### Undo Log

MVCC's multiple versions refer to multiple version snapshots, which are stored in the Undo log, and this log connects all snapshots of a data row through a rollback pointer ROLL_PTR.

For example, in MySQL create a table t, including a primary key id and a field x. We insert a data row first, and then perform two update operations on the data row.

```sql
INSERT INTO t(id, x) VALUES(1, "a");
UPDATE t SET x="b" WHERE id=1;
UPDATE t SET x="c" WHERE id=1;
```

Because we did not use `START TRANSACTION` to treat the above operations as a transaction, according to MySQL's AUTOCOMMIT mechanism, each operation is treated as a transaction, so the above operations involve a total of three transactions. In the snapshot, in addition to recording the transaction version number TRX_ID and the operation, it also records a bit DEL field to indicate whether it is deleted.<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208164808217.png"/> </div><br>

INSERT, UPDATE and DELETE operations create a log and write the transaction version number TRX_ID. DELETE can be thought of as a special UPDATE that additionally sets the DEL field to 1.
### ReadView
MVCC maintains a ReadView structure that contains a list of uncommitted transactions in the current system, TRX_IDs {TRX_ID_1, TRX_ID_2,...} and the minimum TRX_ID_MIN and maximum TRX_ID_MAX values for this list.
<div align=“center”> <img src=“https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208171445674.png”/> </div><br>
When performing a SELECT operation, you can determine whether a data row snapshot can be used based on the relationship between the TRX_ID of the data row snapshot and TRX_ID_MIN and TRX_ID_MAX:
- If TRX_ID < TRX_ID_MIN, the data row snapshot was changed before all current uncommitted transactions, so it can be used.
- If TRX_ID > TRX_ID_MAX, the data row snapshot was changed after the transaction was initiated and is therefore not available.
- If TRX_ID_MIN <= TRX_ID <= TRX_ID_MAX, further judgment is required based on the isolation level:
  - Commit Read: If TRX_ID is in the TRX_IDs list, it means that the transaction corresponding to this data row snapshot has not yet been committed, and the snapshot is not available. Otherwise, it is committed and can be used.
  - Repeatable Read: In both cases, the snapshot is not available for use. Because if it can be used, then other transactions can also read the snapshot of the data row and modify it, which leads to changes in the value of the data row when the current transaction reads it again, i.e., the problem of non-repeatable reads occurs.
In the case that the snapshot of the data row is not available, you need to find the next snapshot along the rollback pointer ROLL_PTR of the Undo Log, and then make the above judgment.
### Snapshot reads vs. current reads
#### 1. Snapshot Read
MVCC's SELECT operation reads the data in the snapshot and does not require locking.
```sql
SELECT * FROM table... ;
```
#### 2. Current Read
Other operations in MVCC that make changes to the database (INSERT, UPDATE, DELETE) require locking operations to read the latest data. As you can see, MVCC is not completely lock-free, it just avoids the locking operation of SELECT.
```sql
INSERT.
UPDATE.
DELETE.
```
When performing a SELECT operation, you can force a locking operation to be specified. The first statement below requires an S lock and the second requires an X lock.
```sql
SELECT * FROM table WHERE? lock in share mode.
SELECT * FROM table WHERE? lock in share mode; SELECT * FROM table WHERE? for update; SELECT * FROM table WHERE?
```
## VI. Next-Key Locks
Next-Key Locks is a locking implementation of the InnoDB storage engine for MySQL.
MVCC cannot solve the phantom read problem, and Next-Key Locks exist to solve this problem. Using MVCC + Next-Key Locks at the REPEATABLE READ isolation level solves the phantom read problem.
### Record Locks
Locks the indexes on the records, not the records themselves.
If the table is not indexed, InnoDB automatically creates a hidden clustered index on the primary key, so Record Locks can still be used.
### Gap Locks
Locks gaps between indexes, but not the indexes themselves. For example, when one transaction executes the following statement, no other transaction can insert 15 in t.c.
```sql
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE.
```
### Next-Key Locks
It is a combination of Record Locks and Gap Locks that locks not only the indexes on the records but also the gaps between the indexes. It locks an interval that is open before and closed after, for example, if an index contains the values 10, 11, 13, and 20, you need to lock the following interval:
```sql
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
```

## VII Theory of Relational Database Design
### Functional dependencies

Functions DependencyA-\>B denotes that A determines B, or B is functionally dependent on A.

If {A1, A2,..., An} is a set of one or more attributes of a relation, and the set of attributes functionally determines all other attributes of the relation and is the smallest, then the set is called a key.

For A-\>B, if a proper subset A' of A can be found such that A'-\> B, then A-\>B is a partial functional dependency, otherwise it is a total functional dependency.

For A-\>B and B-\>C, then A-\>C is a transitive functional dependency.

### Exception

The following student-course relation has the functional dependencies {Sno, Cname} -\> {Sname, Sdept, Mname, Grade}, and the key is {Sno, Cname}. That is, after determining the student and the course, other information can be determined.

| Sno | Sname | Sdept | Mname | Cname | Grade |
| :---: | :---: | :---: | :---: | :---: |:---:|
| 1 | Student-1 | College-1 | Dean-1 | Course-1 | 90 |
| 2 | Student-2 | College-2 | Dean-2 | Course-2 | 80 |
| 2 | Student-2 | College-2 | Dean-2 | Course-1 | 100 |
| 3 | Student-3 | College-2 | Dean-2 | Course-2 | 95 |

Relations that do not conform to the normal form will have many exceptions, mainly four types of exceptions:

- Redundant data: For example, "Student-2" appears twice.
- Update exception: When the information in one record is modified, the same information in another record is not modified.
- Delete exception: When deleting an information, other information will also be lost. For example, if "Course-1" is deleted, the first and third rows need to be deleted, then the information of "Student-1" will be lost.
- Insert exception: For example, if you want to insert information of a student, but this student has not yet selected a course, then it cannot be inserted.

### Normal Form

The normal form theory is to solve the four exceptions mentioned above.

Higher-level normal forms are dependent on lower-level normal forms, and 1NF is the lowest-level normal form.

#### 1. First Normal Form (1NF)

Attributes are indivisible.

#### 2. Second Normal Form (2NF)

Each non-key attribute is functionally dependent on the key.

It can be satisfied by decomposition.

<font size=4> **Before decomposition** </font><br>

| Sno | Sname | Sdept | Mname | Cname | Grade |
| :---: | :---: | :---: | :---: | :---: |:---:|
| 1 | Student-1 | College-1 | Dean-1 | Course-1 | 90 |
| 2 | Student-2 | College-2 | Dean-2 | Course-2 | 80 |
| 2 | Student-2 | College-2 | Dean-2 | Course-1 | 100 |
| 3 | Student-3 | College-2 | Dean-2 | Course-2 | 95 |

In the above student-course relation, {Sno, Cname} is the key, and there are the following functional dependencies:

- Sno -\> Sname, Sdept
- Sdept -\> Mname
- Sno, Cname-\> Grade

Grade is completely functionally dependent on the key, and it has no redundant data. Each student has a specific score for each course.

Sname, Sdept, and Mname are all partially dependent on the key, and when a student takes multiple courses, these data will appear multiple times, resulting in a large amount of redundant data.

<font size=4> **After decomposition** </font><br>

Relation-1

| Sno | Sname | Sdept | Mname |
| :---: | :---: | :---: | :---: |
| 1 | Student-1 | College-1 | Dean-1 |
| 2 | Student-2 | College-2 | Dean-2 |
| 3 | Student-3 | College-2 | Dean-2 |

There are the following functional dependencies:

- Sno -\> Sname, Sdept
- Sdept -\> Mname

Relation-2

| Sno | Cname | Grade |
| :---: | :---: |:---:|
| 1 | Course-1 | 90 |
| 2 | Course-2 | 80 |
| 2 | Course-1 | 100 |
| 3 | Course-2 | 95 |

There are the following functional dependencies:

- Sno, Cname -\> Grade

#### 3. Third Normal Form (3NF)

Non-key attributes do not transitively functionally depend on the key.

There is the following transitive functional dependency in Relation-1:

- Sno -\> Sdept -\> Mname

It can be decomposed as follows:

Relation-11

| Sno | Sname | Sdept |
| :---: | :---: | :---: |
| 1 | Student-1 | College-1 |

Relation-12

| Sno | Sdept | Mname |
| :---: | :---: | :---: |
| 2 | Student-2 | College-2 |
| 3 | Student-3 | College-2 |

| 2 | Student-2 | College-2 |
| 3 | Student-3 | College-2 |

Relationship-12

| Sdept | Mname |
| :---: | :---: |
| College-1 | President-1 |
| College-2 | President-2 |

## ER Diagram

Entity-Relationship, which has three components: entities, attributes, and relationships.

It is used for the conceptual design of relational database systems.

### Three types of relationships among entities

Includes one-to-one, one-to-many, and many-to-many.

- If A to B is a one-to-many relationship, draw an arrow pointing to B;
- If it is one-to-one, draw two arrows;
- If it is many-to-many, draw two unidirectional lines.

The diagram below shows that Course and Student have a one-to-many relationship.

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1d28ad05-39e5-49a2-a6a1-a6f496adba6a.png" width="380px"/> </div><br>

### Representing multiple occurrences of a relationship

How many times an entity appears in a relationship, you need to connect with that many lines.

The diagram below represents a prerequisite relationship for a course. The prerequisite relationship has two Course entities, the first being the prerequisite course, and the second being the subsequent course, so two lines are required to represent this relationship.

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac929ea3-daca-40ec-9e95-4b2fa6678243.png" width="250px"/> </div><br>

### The multi-directionality of a relationship

Although a teacher can teach many courses and can teach many students, for a specific student and course, there is only one teacher teaching, which constitutes a ternary relationship.

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5bb1b38a-527e-4802-a385-267dadbd30ba.png" width="350px"/> </div><br>

### Representing subclasses

Connect classes and subclasses with a triangle and two lines, and connect the attributes and relationships related to the subclass to the subclass, while those related to the class and subclass are connected to the class.

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/14389ea4-8d96-4e96-9f76-564ca3324c1e.png" width="450px"/> </div><br>

## References

- AbrahamSilberschatz, HenryF.Korth, S.Sudarshan, et al. Database System Concepts [M]. China Machine Press, 2006.
- Schwarts. MySQL High Performance (3rd Edition) [M]. Publishing House of Electronics Industry, 2013.
- ShiJiaquan. An Introduction to Database Systems [M]. Tsinghua University Press, 2006.
- [The InnoDB Storage Engine](https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html)
- [Transaction isolation levels](https://www.slideshare.net/ErnestoHernandezRodriguez/transaction-isolation-levels)
- [Concurrency Control](http://scanftree.com/dbms/2-phase-locking-protocol)
- [The Nightmare of Locking, Blocking and Isolation Levels!](https://www.slideshare.net/brshristov/the-nightmare-of-locking-blocking-and-isolation-levels-46391666)
- [Database Normalization and Normal Forms with an Example](https://aksakalli.github.io/2012/03/12/database-normalization-and-normal-forms-with-an-example.html)- [The Basics of the InnoDB Undo Logging and History System](https://blog.jcole.us/2014/04/16/the-basics-of-the-innodb-undo-logging-and-history-system/)
- [MySQL Locking for the Busy Web Developer](https://www.brightbox.com/blog/2013/10/31/on-mysql-locks/)
- [A Gentle Introduction to MySQL and InnoDB](https://draveness.me/mysql-innodb)
- [The Relationship between Transaction Isolation Levels and Locks in InnoDB](https://tech.meituan.com/2014/08/20/innodb-lock.html)